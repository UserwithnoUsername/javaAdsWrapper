// Targeted by JavaCPP version 1.5.10: DO NOT EDIT THIS FILE

package com.forester;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

public class AdsLib extends com.forester.AdsLibConfig {
    static { Loader.load(); }

// Parsed from AdsLib.h

// SPDX-License-Identifier: MIT
/**
   Copyright (c) 2020 - 2022 Beckhoff Automation GmbH & Co. KG
 */

// #pragma once

// #if defined(USE_TWINCAT_ROUTER)
// #include "TwinCAT/AdsLib.h"
// #else
// #include "standalone/AdsLib.h"
// #endif

// #include "Sockets.h"

/**
 * Reads data synchronously from an ADS server.
 * @param port [in] port number of an Ads port that had previously been opened with AdsPortOpenEx().
 * @param pAddr [in] Structure with NetId and port number of the ADS server.
 * @param indexGroup [in] Index Group.
 * @param indexOffset [in] Index Offset.
 * @param bufferLength [in] Length of the data in bytes.
 * @param buffer [out] Pointer to a data buffer that will receive the data.
 * @param bytesRead [out] pointer to a variable. If successful, this variable will return the number of actually read data bytes.
 * @return [ADS Return Code](https://infosys.beckhoff.com/content/1031/tcadscommon/html/ads_returncodes.htm?id=1666172286265530469)
 */
public static native long AdsSyncReadReqEx2(long port, @Const AmsAddr pAddr, @Cast("uint32_t") int indexGroup,
		       @Cast("uint32_t") int indexOffset, @Cast("uint32_t") int bufferLength,
		       Pointer buffer, @Cast("uint32_t*") IntPointer bytesRead);
public static native long AdsSyncReadReqEx2(long port, @Const AmsAddr pAddr, @Cast("uint32_t") int indexGroup,
		       @Cast("uint32_t") int indexOffset, @Cast("uint32_t") int bufferLength,
		       Pointer buffer, @Cast("uint32_t*") IntBuffer bytesRead);
public static native long AdsSyncReadReqEx2(long port, @Const AmsAddr pAddr, @Cast("uint32_t") int indexGroup,
		       @Cast("uint32_t") int indexOffset, @Cast("uint32_t") int bufferLength,
		       Pointer buffer, @Cast("uint32_t*") int[] bytesRead);

/**
 * Reads the identification and version number of an ADS server.
 * @param port [in] port number of an Ads port that had previously been opened with AdsPortOpenEx().
 * @param pAddr [in] Structure with NetId and port number of the ADS server.
 * @param devName [out] Pointer to a character string of at least 16 bytes, that will receive the name of the ADS device.
 * @param version [out] Address of a variable of type AdsVersion, which will receive the version number, revision number and the build number.
 * @return [ADS Return Code](https://infosys.beckhoff.com/content/1031/tcadscommon/html/ads_returncodes.htm?id=1666172286265530469)
 */
public static native long AdsSyncReadDeviceInfoReqEx(long port, @Const AmsAddr pAddr, @Cast("char*") BytePointer devName,
				AdsVersion version);
public static native long AdsSyncReadDeviceInfoReqEx(long port, @Const AmsAddr pAddr, @Cast("char*") ByteBuffer devName,
				AdsVersion version);
public static native long AdsSyncReadDeviceInfoReqEx(long port, @Const AmsAddr pAddr, @Cast("char*") byte[] devName,
				AdsVersion version);

/**
 * Reads the ADS status and the device status from an ADS server.
 * @param port [in] port number of an Ads port that had previously been opened with AdsPortOpenEx().
 * @param pAddr [in] Structure with NetId and port number of the ADS server.
 * @param adsState [out] Address of a variable that will receive the ADS status (see data type [ADSSTATE](https://infosys.beckhoff.com/content/1031/tcadsdll2/html/tcadsdll_enumadsstate.htm?id=2714257434501002224).
 * @param devState [out] Address of a variable that will receive the device status.
 * @return [ADS Return Code](https://infosys.beckhoff.com/content/1031/tcadscommon/html/ads_returncodes.htm?id=1666172286265530469)
 */
public static native long AdsSyncReadStateReqEx(long port, @Const AmsAddr pAddr, @Cast("uint16_t*") ShortPointer adsState,
			   @Cast("uint16_t*") ShortPointer devState);
public static native long AdsSyncReadStateReqEx(long port, @Const AmsAddr pAddr, @Cast("uint16_t*") ShortBuffer adsState,
			   @Cast("uint16_t*") ShortBuffer devState);
public static native long AdsSyncReadStateReqEx(long port, @Const AmsAddr pAddr, @Cast("uint16_t*") short[] adsState,
			   @Cast("uint16_t*") short[] devState);

/**
 * Writes data synchronously into an ADS server and receives data back from the ADS server.
 * @param port [in]  port number of an Ads port that had previously been opened with AdsPortOpenEx().
 * @param pAddr [in] Structure with NetId and port number of the ADS server.
 * @param indexGroup [in] Index Group.
 * @param indexOffset [in] Index Offset.
 * @param readLength [in] Length, in bytes, of the read buffer readData.
 * @param readData [out] Buffer for data read from the ADS server.
 * @param writeLength [in] Length of the data, in bytes, send to the ADS server.
 * @param writeData [in] Buffer with data send to the ADS server.
 * @param bytesRead [out] pointer to a variable. If successful, this variable will return the number of actually read data bytes.
 * @return [ADS Return Code](https://infosys.beckhoff.com/content/1031/tcadscommon/html/ads_returncodes.htm?id=1666172286265530469)
 */
public static native long AdsSyncReadWriteReqEx2(long port, @Const AmsAddr pAddr,
			    @Cast("uint32_t") int indexGroup, @Cast("uint32_t") int indexOffset,
			    @Cast("uint32_t") int readLength, Pointer readData,
			    @Cast("uint32_t") int writeLength, @Const Pointer writeData,
			    @Cast("uint32_t*") IntPointer bytesRead);
public static native long AdsSyncReadWriteReqEx2(long port, @Const AmsAddr pAddr,
			    @Cast("uint32_t") int indexGroup, @Cast("uint32_t") int indexOffset,
			    @Cast("uint32_t") int readLength, Pointer readData,
			    @Cast("uint32_t") int writeLength, @Const Pointer writeData,
			    @Cast("uint32_t*") IntBuffer bytesRead);
public static native long AdsSyncReadWriteReqEx2(long port, @Const AmsAddr pAddr,
			    @Cast("uint32_t") int indexGroup, @Cast("uint32_t") int indexOffset,
			    @Cast("uint32_t") int readLength, Pointer readData,
			    @Cast("uint32_t") int writeLength, @Const Pointer writeData,
			    @Cast("uint32_t*") int[] bytesRead);

/**
 * Writes data synchronously to an ADS server.
 * @param port [in] port number of an Ads port that had previously been opened with AdsPortOpenEx().
 * @param pAddr [in] Structure with NetId and port number of the ADS server.
 * @param indexGroup [in] Index Group.
 * @param indexOffset [in] Index Offset.
 * @param bufferLength [in] Length of the data, in bytes, send to the ADS server.
 * @param buffer [in] Buffer with data send to the ADS server.
 * @return [ADS Return Code](https://infosys.beckhoff.com/content/1031/tcadscommon/html/ads_returncodes.htm?id=1666172286265530469)
 */
public static native long AdsSyncWriteReqEx(long port, @Const AmsAddr pAddr, @Cast("uint32_t") int indexGroup,
		       @Cast("uint32_t") int indexOffset, @Cast("uint32_t") int bufferLength,
		       @Const Pointer buffer);

/**
 * Changes the ADS status and the device status of an ADS server.
 * @param port [in] port number of an Ads port that had previously been opened with AdsPortOpenEx().
 * @param pAddr [in] Structure with NetId and port number of the ADS server.
 * @param adsState [in] New ADS status.
 * @param devState [in] New device status.
 * @param bufferLength [in] Length of the additional data, in bytes, send to the ADS server.
 * @param buffer [in] Buffer with additional data send to the ADS server.
 * @return [ADS Return Code](https://infosys.beckhoff.com/content/1031/tcadscommon/html/ads_returncodes.htm?id=1666172286265530469)
 */
public static native long AdsSyncWriteControlReqEx(long port, @Const AmsAddr pAddr,
			      @Cast("uint16_t") short adsState, @Cast("uint16_t") short devState,
			      @Cast("uint32_t") int bufferLength, @Const Pointer buffer);

/**
 * A notification is defined within an ADS server (e.g. PLC). When a
 * certain event occurs a function (the callback function) is invoked in
 * the ADS client (C program).
 * @param port [in] port number of an Ads port that had previously been opened with AdsPortOpenEx().
 * @param pAddr [in] Structure with NetId and port number of the ADS server.
 * @param indexGroup [in] Index Group.
 * @param indexOffset [in] Index Offset.
 * @param pAttrib [in] Pointer to the structure that contains further information.
 * @param pFunc [in] Pointer to the structure describing the callback function.
 * @param hUser [in] 32-bit value that is passed to the callback function.
 * @param pNotification [out] Address of the variable that will receive the handle of the notification.
 * @return [ADS Return Code](https://infosys.beckhoff.com/content/1031/tcadscommon/html/ads_returncodes.htm?id=1666172286265530469)
 */
public static native long AdsSyncAddDeviceNotificationReqEx(long port, @Const AmsAddr pAddr,
				       @Cast("uint32_t") int indexGroup,
				       @Cast("uint32_t") int indexOffset,
				       @Const AdsNotificationAttrib pAttrib,
				       PAdsNotificationFuncEx pFunc,
				       @Cast("uint32_t") int hUser, @Cast("uint32_t*") IntPointer pNotification);
public static native long AdsSyncAddDeviceNotificationReqEx(long port, @Const AmsAddr pAddr,
				       @Cast("uint32_t") int indexGroup,
				       @Cast("uint32_t") int indexOffset,
				       @Const AdsNotificationAttrib pAttrib,
				       PAdsNotificationFuncEx pFunc,
				       @Cast("uint32_t") int hUser, @Cast("uint32_t*") IntBuffer pNotification);
public static native long AdsSyncAddDeviceNotificationReqEx(long port, @Const AmsAddr pAddr,
				       @Cast("uint32_t") int indexGroup,
				       @Cast("uint32_t") int indexOffset,
				       @Const AdsNotificationAttrib pAttrib,
				       PAdsNotificationFuncEx pFunc,
				       @Cast("uint32_t") int hUser, @Cast("uint32_t*") int[] pNotification);

/**
 * A notification defined previously is deleted from an ADS server.
 * @param port [in] port number of an Ads port that had previously been opened with AdsPortOpenEx().
 * @param pAddr [in] Structure with NetId and port number of the ADS server.
 * @param hNotification [in] Address of the variable that contains the handle of the notification.
 * @return [ADS Return Code](https://infosys.beckhoff.com/content/1031/tcadscommon/html/ads_returncodes.htm?id=1666172286265530469)
 */
public static native long AdsSyncDelDeviceNotificationReqEx(long port, @Const AmsAddr pAddr,
				       @Cast("uint32_t") int hNotification);

/**
 * Read the configured timeout for the ADS functions. The standard value is 5000 ms.
 * @param port [in] port number of an Ads port that had previously been opened with AdsPortOpenEx().
 * @param timeout [out] Buffer to store timeout value in ms.
 * @return [ADS Return Code](https://infosys.beckhoff.com/content/1031/tcadscommon/html/ads_returncodes.htm?id=1666172286265530469)
 */
public static native long AdsSyncGetTimeoutEx(long port, @Cast("uint32_t*") IntPointer timeout);
public static native long AdsSyncGetTimeoutEx(long port, @Cast("uint32_t*") IntBuffer timeout);
public static native long AdsSyncGetTimeoutEx(long port, @Cast("uint32_t*") int[] timeout);
/**
 * Add new ams route to target system
 * @param ams [in] address of the target system
 * @param ip [in] address of the target system
 * @return [ADS Return Code](https://infosys.beckhoff.com/content/1031/tcadscommon/html/ads_returncodes.htm?id=1666172286265530469)
 */
@Namespace("bhf::ads") public static native long AddLocalRoute(@ByVal AmsNetId ams, @Cast("const char*") BytePointer ip);
@Namespace("bhf::ads") public static native long AddLocalRoute(@ByVal AmsNetId ams, String ip);

/**
 * Delete ams route that had previously been added with AddLocalRoute().
 * @param ams [in] address of the target system
 */
@Namespace("bhf::ads") public static native void DelLocalRoute(@ByVal AmsNetId ams);

/**
 * Change local NetId
 * @param ams [in] local AmsNetId
 */
@Namespace("bhf::ads") public static native void SetLocalAddress(@ByVal AmsNetId ams);

/**
 * Add an ADS route to a remote TwinCAT system
 * @param remote [in] hostname or ip address of the remote TwinCAT system
 * @param destNetId [in] AmsNetId of the routes destination
 * @param destAddr [in] hostname or ip address of the routes destination
 * @param routeName [in] name of the new route
 * @param remoteUsername [in] username on the remote TwinCAT system
 * @param remotePassword [in] password for the user on the remote TwinCAT system
 * @return [ADS Return Code](https://infosys.beckhoff.com/content/1031/tcadscommon/html/ads_returncodes.htm?id=1666172286265530469)
 */
@Namespace("bhf::ads") public static native long AddRemoteRoute(@StdString BytePointer remote, @ByVal AmsNetId destNetId,
		    @StdString BytePointer destAddr, @StdString BytePointer routeName,
		    @StdString BytePointer remoteUsername,
		    @StdString BytePointer remotePassword);
@Namespace("bhf::ads") public static native long AddRemoteRoute(@StdString String remote, @ByVal AmsNetId destNetId,
		    @StdString String destAddr, @StdString String routeName,
		    @StdString String remoteUsername,
		    @StdString String remotePassword);

/**
 * Read AmsNetId of some TwinCAT remote host
 * @param remote [in] hostname or ip address of the remote TwinCAT system
 * @param netId [out] on success the AmsNetId of the remote TwinCAT system is written here
 * @return [ADS Return Code](https://infosys.beckhoff.com/content/1031/tcadscommon/html/ads_returncodes.htm?id=1666172286265530469)
 */
@Namespace("bhf::ads") public static native long GetRemoteAddress(@StdString BytePointer remote, @ByRef AmsNetId netId);
@Namespace("bhf::ads") public static native long GetRemoteAddress(@StdString String remote, @ByRef AmsNetId netId);



// #define AdsAddRoute bhf::ads::AddLocalRoute
// #define AdsDelRoute bhf::ads::DelLocalRoute
// #define AdsSetLocalAddress bhf::ads::SetLocalAddress


// Parsed from AdsDef.h

// SPDX-License-Identifier: MIT
/**
   Copyright (c) 2015 - 2022 Beckhoff Automation GmbH & Co. KG
 */

// #pragma once

// #if defined(USE_TWINCAT_ROUTER)
// #include "TwinCAT/AdsDef.h"
// #else
// #include "standalone/AdsDef.h"
// #endif

// #include <iosfwd>
public static native @Cast("bool") @Name("operator <") boolean lessThan(@Const @ByRef AmsNetId lhs, @Const @ByRef AmsNetId rhs);
public static native @Cast("bool") @Name("operator <") boolean lessThan(@Const @ByRef AmsAddr lhs, @Const @ByRef AmsAddr rhs);
public static native @Cast("std::ostream*") @ByRef @Name("operator <<") Pointer shiftLeft(@Cast("std::ostream*") @ByRef Pointer os, @Const @ByRef AmsNetId netId);
public static native @ByVal AmsNetId make_AmsNetId(@StdString BytePointer addr);
public static native @ByVal AmsNetId make_AmsNetId(@StdString String addr);
/** enum bhf::ads::nSystemServiceOpenFile */
public static final int
	SYSTEMSERVICE_OPENGENERIC = 1;




// Parsed from standalone/AdsLib.h

// SPDX-License-Identifier: MIT
/** \file
   Copyright (c) 2015 - 2022 Beckhoff Automation GmbH & Co. KG
 */
// #pragma once

// #include "AdsDef.h"

/**
 * The connection (communication port) to the message router is
 * closed. The port to be closed must previously have been opened via
 * an AdsPortOpenEx() call.
 * @param port [in] port number of an Ads port that had previously been opened with AdsPortOpenEx().
 * @return [ADS Return Code](https://infosys.beckhoff.com/content/1031/tcadscommon/html/ads_returncodes.htm?id=1666172286265530469)
 */
public static native long AdsPortCloseEx(long port);

/**
 * Establishes a connection (communication port) to the message
 * router. The port number returned by AdsPortOpenEx() is required as
 * parameter for further AdsLib function calls.
 * @return port number of a new Ads port or 0 if no more ports available
 */
public static native long AdsPortOpenEx();

/**
 * Returns the local NetId and port number.
 * @param port [in] port number of an Ads port that had previously been opened with AdsPortOpenEx().
 * @param pAddr [out] Pointer to the structure of type AmsAddr.
 * @return [ADS Return Code](https://infosys.beckhoff.com/content/1031/tcadscommon/html/ads_returncodes.htm?id=1666172286265530469)
 */
public static native long AdsGetLocalAddressEx(long port, AmsAddr pAddr);

/**
 * Alters the timeout for the ADS functions. The standard value is 5000 ms.
 * @param port [in] port number of an Ads port that had previously been opened with AdsPortOpenEx().
 * @param timeout [in] Timeout in ms.
 * @return [ADS Return Code](https://infosys.beckhoff.com/content/1031/tcadscommon/html/ads_returncodes.htm?id=1666172286265530469)
 */
public static native long AdsSyncSetTimeoutEx(long port, @Cast("uint32_t") int timeout);


// Parsed from standalone/AdsDef.h

// SPDX-License-Identifier: MIT
/** \file
   Copyright (c) 2015 - 2022 Beckhoff Automation GmbH & Co. KG
 */

// #pragma once

// #include <cstdint>
// #include <string>

public static final int ADS_TCP_SERVER_PORT = 0xBF02;

////////////////////////////////////////////////////////////////////////////////
// AMS Ports
/** enum AMSPORT */
public static final short
	AMSPORT_LOGGER = (short)(100),
	AMSPORT_R0_RTIME = (short)(200),
	AMSPORT_R0_TRACE = (short)((AMSPORT_R0_RTIME + 90)),
	AMSPORT_R0_IO = (short)(300),
	AMSPORT_R0_SPS = (short)(400),
	AMSPORT_R0_NC = (short)(500),
	AMSPORT_R0_ISG = (short)(550),
	AMSPORT_R0_PCS = (short)(600),
	AMSPORT_R0_PLC = (short)(801),
	AMSPORT_R0_PLC_RTS1 = (short)(801),
	AMSPORT_R0_PLC_RTS2 = (short)(811),
	AMSPORT_R0_PLC_RTS3 = (short)(821),
	AMSPORT_R0_PLC_RTS4 = (short)(831),
	AMSPORT_R0_PLC_TC3 = (short)(851);

////////////////////////////////////////////////////////////////////////////////
// ADS Cmd Ids
public static final int ADSSRVID_INVALID = 0x00;
public static final int ADSSRVID_READDEVICEINFO = 0x01;
public static final int ADSSRVID_READ = 0x02;
public static final int ADSSRVID_WRITE = 0x03;
public static final int ADSSRVID_READSTATE = 0x04;
public static final int ADSSRVID_WRITECTRL = 0x05;
public static final int ADSSRVID_ADDDEVICENOTE = 0x06;
public static final int ADSSRVID_DELDEVICENOTE = 0x07;
public static final int ADSSRVID_DEVICENOTE = 0x08;
public static final int ADSSRVID_READWRITE = 0x09;

////////////////////////////////////////////////////////////////////////////////
// ADS reserved index groups
public static final int ADSIGRP_SYMTAB = 0xF000;
public static final int ADSIGRP_SYMNAME = 0xF001;
public static final int ADSIGRP_SYMVAL = 0xF002;

public static final int ADSIGRP_SYM_HNDBYNAME = 0xF003;
public static final int ADSIGRP_SYM_VALBYNAME = 0xF004;
public static final int ADSIGRP_SYM_VALBYHND = 0xF005;
public static final int ADSIGRP_SYM_RELEASEHND = 0xF006;
public static final int ADSIGRP_SYM_INFOBYNAME = 0xF007;
public static final int ADSIGRP_SYM_VERSION = 0xF008;
public static final int ADSIGRP_SYM_INFOBYNAMEEX = 0xF009;

public static final int ADSIGRP_SYM_DOWNLOAD = 0xF00A;
public static final int ADSIGRP_SYM_UPLOAD = 0xF00B;
public static final int ADSIGRP_SYM_UPLOADINFO = 0xF00C;
public static final int ADSIGRP_SYM_DOWNLOAD2 = 0xF00D;
public static final int ADSIGRP_SYM_DT_UPLOAD = 0xF00E;
public static final int ADSIGRP_SYM_UPLOADINFO2 = 0xF00F;

/** notification of named handle */
public static final int ADSIGRP_SYMNOTE = 0xF010;

/**
 * AdsRW  IOffs list size or 0 (=0 -> list size == WLength/3*sizeof(ULONG))
 * @param W: {list of IGrp, IOffs, Length}
 * @param R: if IOffs != 0 then {list of results} and {list of data}
 * @param R: if IOffs == 0 then only data (sum result)
 */
public static final int ADSIGRP_SUMUP_READ = 0xF080;

/**
 * AdsRW  IOffs list size
 * @param W: {list of IGrp, IOffs, Length} followed by {list of data}
 * @param R: list of results
 */
public static final int ADSIGRP_SUMUP_WRITE = 0xF081;

/**
 * AdsRW  IOffs list size
 * @param W: {list of IGrp, IOffs, RLength, WLength} followed by {list of data}
 * @param R: {list of results, RLength} followed by {list of data}
 */
public static final int ADSIGRP_SUMUP_READWRITE = 0xF082;

/**
 * AdsRW  IOffs list size
 * @param W: {list of IGrp, IOffs, Length}
 */
public static final int ADSIGRP_SUMUP_READEX = 0xF083;

/**
 * AdsRW  IOffs list size
 * @param W: {list of IGrp, IOffs, Length}
 * @param R: {list of results, Length} followed by {list of data (returned lengths)}
 */
public static final int ADSIGRP_SUMUP_READEX2 = 0xF084;

/**
 * AdsRW  IOffs list size
 * @param W: {list of IGrp, IOffs, Attrib}
 * @param R: {list of results, handles}
 */
public static final int ADSIGRP_SUMUP_ADDDEVNOTE = 0xF085;

/**
 * AdsRW  IOffs list size
 * @param W: {list of handles}
 * @param R: {list of results, Length} followed by {list of data}
 */
public static final int ADSIGRP_SUMUP_DELDEVNOTE = 0xF086;

/** read/write input byte(s) */
public static final int ADSIGRP_IOIMAGE_RWIB = 0xF020;
/** read/write input bit */
public static final int ADSIGRP_IOIMAGE_RWIX = 0xF021;
/** read input size (in byte) */
public static final int ADSIGRP_IOIMAGE_RISIZE = 0xF025;
/** read/write output byte(s) */
public static final int ADSIGRP_IOIMAGE_RWOB = 0xF030;
/** read/write output bit */
public static final int ADSIGRP_IOIMAGE_RWOX = 0xF031;
/** read output size (in byte) */
public static final int ADSIGRP_IOIMAGE_ROSIZE = 0xF035;
/** write inputs to null */
public static final int ADSIGRP_IOIMAGE_CLEARI = 0xF040;
/** write outputs to null */
public static final int ADSIGRP_IOIMAGE_CLEARO = 0xF050;
/** read input and write output byte(s) */
public static final int ADSIGRP_IOIMAGE_RWIOB = 0xF060;

/** state, name, etc... */
public static final int ADSIGRP_DEVICE_DATA = 0xF100;
/** ads state of device */
public static final int ADSIOFFS_DEVDATA_ADSSTATE = 0x0000;
/** device state */
public static final int ADSIOFFS_DEVDATA_DEVSTATE = 0x0002;

////////////////////////////////////////////////////////////////////////////////
// Global Return codes
public static final int ERR_GLOBAL = 0x0000;

/** target port not found, possibly the ADS Server is not started */
public static final int GLOBALERR_TARGET_PORT = 
	(0x06 +               
	 ERR_GLOBAL);
/** target machine not found, possibly missing ADS routes */
public static final int GLOBALERR_MISSING_ROUTE = 
	(0x07 +                 
	 ERR_GLOBAL);
/** No memory */
public static final int GLOBALERR_NO_MEMORY = (0x19 + ERR_GLOBAL);
/** TCP send error */
public static final int GLOBALERR_TCP_SEND = (0x1A + ERR_GLOBAL);

////////////////////////////////////////////////////////////////////////////////
// Router Return codes
public static final int ERR_ROUTER = 0x0500;

/** The desired port number is already assigned */
public static final int ROUTERERR_PORTALREADYINUSE = 
	(0x06 + ERR_ROUTER);
/** Port not registered */
public static final int ROUTERERR_NOTREGISTERED = (0x07 + ERR_ROUTER);
/** The maximum number of Ports reached */
public static final int ROUTERERR_NOMOREQUEUES = 
	(0x08 + ERR_ROUTER);

////////////////////////////////////////////////////////////////////////////////
// ADS Return codes
public static final int ADSERR_NOERR = 0x00;
public static final int ERR_ADSERRS = 0x0700;

/** Error class < device error > */
public static final int ADSERR_DEVICE_ERROR = 
	(0x00 + ERR_ADSERRS);
/** Service is not supported by server */
public static final int ADSERR_DEVICE_SRVNOTSUPP = 
	(0x01 + ERR_ADSERRS);
/** invalid indexGroup */
public static final int ADSERR_DEVICE_INVALIDGRP = (0x02 + ERR_ADSERRS);
/** invalid indexOffset */
public static final int ADSERR_DEVICE_INVALIDOFFSET = 
	(0x03 + ERR_ADSERRS);
/** reading/writing not permitted */
public static final int ADSERR_DEVICE_INVALIDACCESS = 
	(0x04 + ERR_ADSERRS);
/** parameter size not correct */
public static final int ADSERR_DEVICE_INVALIDSIZE = 
	(0x05 + ERR_ADSERRS);
/** invalid parameter value(s) */
public static final int ADSERR_DEVICE_INVALIDDATA = 
	(0x06 + ERR_ADSERRS);
/** device is not in a ready state */
public static final int ADSERR_DEVICE_NOTREADY = 
	(0x07 + ERR_ADSERRS);
/** device is busy */
public static final int ADSERR_DEVICE_BUSY = (0x08 + ERR_ADSERRS);
/** invalid context (must be InWindows) */
public static final int ADSERR_DEVICE_INVALIDCONTEXT = 
	(0x09 + ERR_ADSERRS);
/** out of memory */
public static final int ADSERR_DEVICE_NOMEMORY = (0x0A + ERR_ADSERRS);
/** invalid parameter value(s) */
public static final int ADSERR_DEVICE_INVALIDPARM = 
	(0x0B + ERR_ADSERRS);
/** not found (files, ...) */
public static final int ADSERR_DEVICE_NOTFOUND = 
	(0x0C + ERR_ADSERRS);
/** syntax error in comand or file */
public static final int ADSERR_DEVICE_SYNTAX = 
	(0x0D + ERR_ADSERRS);
/** objects do not match */
public static final int ADSERR_DEVICE_INCOMPATIBLE = 
	(0x0E + ERR_ADSERRS);
/** object already exists */
public static final int ADSERR_DEVICE_EXISTS = (0x0F + ERR_ADSERRS);
/** symbol not found */
public static final int ADSERR_DEVICE_SYMBOLNOTFOUND = 
	(0x10 + ERR_ADSERRS);
/** symbol version invalid, possibly caused by an 'onlinechange' -> try to release handle and get a new one */
public static final int ADSERR_DEVICE_SYMBOLVERSIONINVALID = 
	(0x11 +                            
	 ERR_ADSERRS);
/** server is in invalid state */
public static final int ADSERR_DEVICE_INVALIDSTATE = 
	(0x12 + ERR_ADSERRS);
/** AdsTransMode not supported */
public static final int ADSERR_DEVICE_TRANSMODENOTSUPP = 
	(0x13 + ERR_ADSERRS);
/** Notification handle is invalid, possibly caussed by an 'onlinechange' -> try to release handle and get a new one */
public static final int ADSERR_DEVICE_NOTIFYHNDINVALID = 
	(0x14 +                        
	 ERR_ADSERRS);
/** Notification client not registered */
public static final int ADSERR_DEVICE_CLIENTUNKNOWN = 
	(0x15 + ERR_ADSERRS);
/** no more notification handles */
public static final int ADSERR_DEVICE_NOMOREHDLS = 
	(0x16 + ERR_ADSERRS);
/** size for watch to big */
public static final int ADSERR_DEVICE_INVALIDWATCHSIZE = 
	(0x17 + ERR_ADSERRS);
/** device not initialized */
public static final int ADSERR_DEVICE_NOTINIT = 
	(0x18 + ERR_ADSERRS);
/** device has a timeout */
public static final int ADSERR_DEVICE_TIMEOUT = (0x19 + ERR_ADSERRS);
/** query interface failed */
public static final int ADSERR_DEVICE_NOINTERFACE = 
	(0x1A + ERR_ADSERRS);
/** wrong interface required */
public static final int ADSERR_DEVICE_INVALIDINTERFACE = 
	(0x1B + ERR_ADSERRS);
/** class ID is invalid */
public static final int ADSERR_DEVICE_INVALIDCLSID = 
	(0x1C + ERR_ADSERRS);
/** object ID is invalid */
public static final int ADSERR_DEVICE_INVALIDOBJID = 
	(0x1D + ERR_ADSERRS);
/** request is pending */
public static final int ADSERR_DEVICE_PENDING = (0x1E + ERR_ADSERRS);
/** request is aborted */
public static final int ADSERR_DEVICE_ABORTED = (0x1F + ERR_ADSERRS);
/** signal warning */
public static final int ADSERR_DEVICE_WARNING = (0x20 + ERR_ADSERRS);
/** invalid array index */
public static final int ADSERR_DEVICE_INVALIDARRAYIDX = 
	(0x21 + ERR_ADSERRS);
/** symbol not active, possibly caussed by an 'onlinechange' -> try to release handle and get a new one */
public static final int ADSERR_DEVICE_SYMBOLNOTACTIVE = 
	(0x22 +                       
	 ERR_ADSERRS);
/** access denied */
public static final int ADSERR_DEVICE_ACCESSDENIED = (0x23 + ERR_ADSERRS);
/** no license found -> Activate license for TwinCAT 3 function*/
public static final int ADSERR_DEVICE_LICENSENOTFOUND = 
	(0x24 +                       
	 ERR_ADSERRS);
/** license expired */
public static final int ADSERR_DEVICE_LICENSEEXPIRED = 
	(0x25 + ERR_ADSERRS);
/** license exceeded */
public static final int ADSERR_DEVICE_LICENSEEXCEEDED = 
	(0x26 + ERR_ADSERRS);
/** license invalid */
public static final int ADSERR_DEVICE_LICENSEINVALID = 
	(0x27 + ERR_ADSERRS);
/** license invalid system id */
public static final int ADSERR_DEVICE_LICENSESYSTEMID = 
	(0x28 + ERR_ADSERRS);
/** license not time limited */
public static final int ADSERR_DEVICE_LICENSENOTIMELIMIT = 
	(0x29 + ERR_ADSERRS);
/** license issue time in the future */
public static final int ADSERR_DEVICE_LICENSEFUTUREISSUE = 
	(0x2A + ERR_ADSERRS);
/** license time period to long */
public static final int ADSERR_DEVICE_LICENSETIMETOLONG = 
	(0x2B + ERR_ADSERRS);
/** exception in device specific code -> Check each device transistions */
public static final int ADSERR_DEVICE_EXCEPTION = 
	(0x2C +                 
	 ERR_ADSERRS);
/** license file read twice */
public static final int ADSERR_DEVICE_LICENSEDUPLICATED = 
	(0x2D + ERR_ADSERRS);
/** invalid signature */
public static final int ADSERR_DEVICE_SIGNATUREINVALID = 
	(0x2E + ERR_ADSERRS);
/** public key certificate */
public static final int ADSERR_DEVICE_CERTIFICATEINVALID = 
	(0x2F + ERR_ADSERRS);

/** Error class < client error > */
public static final int ADSERR_CLIENT_ERROR = 
	(0x40 + ERR_ADSERRS);
/** invalid parameter at service call */
public static final int ADSERR_CLIENT_INVALIDPARM = 
	(0x41 + ERR_ADSERRS);
/** polling list	is empty */
public static final int ADSERR_CLIENT_LISTEMPTY = 
	(0x42 + ERR_ADSERRS);
/** var connection already in use */
public static final int ADSERR_CLIENT_VARUSED = 
	(0x43 + ERR_ADSERRS);
/** invoke id in use */
public static final int ADSERR_CLIENT_DUPLINVOKEID = (0x44 + ERR_ADSERRS);
/** timeout elapsed -> Check ADS routes of sender and receiver and your [firewall setting](http://infosys.beckhoff.com/content/1033/tcremoteaccess/html/tcremoteaccess_firewall.html?id=12027) */
public static final int ADSERR_CLIENT_SYNCTIMEOUT = 
	(0x45 +                   
	 ERR_ADSERRS);
/** error in win32 subsystem */
public static final int ADSERR_CLIENT_W32ERROR = 
	(0x46 + ERR_ADSERRS);
/** Invalid client timeout value */
public static final int ADSERR_CLIENT_TIMEOUTINVALID = 
	(0x47 + ERR_ADSERRS);
/** ads dll */
public static final int ADSERR_CLIENT_PORTNOTOPEN = (0x48 + ERR_ADSERRS);
/** ads dll */
public static final int ADSERR_CLIENT_NOAMSADDR = (0x49 + ERR_ADSERRS);
/** internal error in ads sync */
public static final int ADSERR_CLIENT_SYNCINTERNAL = 
	(0x50 + ERR_ADSERRS);
/** hash table overflow */
public static final int ADSERR_CLIENT_ADDHASH = (0x51 + ERR_ADSERRS);
/** key not found in hash table */
public static final int ADSERR_CLIENT_REMOVEHASH = 
	(0x52 + ERR_ADSERRS);
/** no more symbols in cache */
public static final int ADSERR_CLIENT_NOMORESYM = 
	(0x53 + ERR_ADSERRS);
/** invalid response received */
public static final int ADSERR_CLIENT_SYNCRESINVALID = 
	(0x54 + ERR_ADSERRS);
/** sync port is locked */
public static final int ADSERR_CLIENT_SYNCPORTLOCKED = 
	(0x55 + ERR_ADSERRS);

// #pragma pack(push, 1)

/**
 * \brief The NetId of and ADS device can be represented in this structure.
 */
@NoOffset public static class AmsNetId extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public AmsNetId(Pointer p) { super(p); }

	/** NetId, consisting of 6 digits. */
	public native @Cast("uint8_t") byte b(int i); public native AmsNetId b(int i, byte setter);
	@MemberGetter public native @Cast("uint8_t*") BytePointer b();

	public AmsNetId(@Cast("uint32_t") int ipv4Addr/*=0*/) { super((Pointer)null); allocate(ipv4Addr); }
	private native void allocate(@Cast("uint32_t") int ipv4Addr/*=0*/);
	public AmsNetId() { super((Pointer)null); allocate(); }
	private native void allocate();
	public AmsNetId(@StdString BytePointer addr) { super((Pointer)null); allocate(addr); }
	private native void allocate(@StdString BytePointer addr);
	public AmsNetId(@StdString String addr) { super((Pointer)null); allocate(addr); }
	private native void allocate(@StdString String addr);
	public AmsNetId(@Cast("uint8_t") byte arg0, @Cast("uint8_t") byte arg1, @Cast("uint8_t") byte arg2, @Cast("uint8_t") byte arg3, @Cast("uint8_t") byte arg4, @Cast("uint8_t") byte arg5) { super((Pointer)null); allocate(arg0, arg1, arg2, arg3, arg4, arg5); }
	private native void allocate(@Cast("uint8_t") byte arg0, @Cast("uint8_t") byte arg1, @Cast("uint8_t") byte arg2, @Cast("uint8_t") byte arg3, @Cast("uint8_t") byte arg4, @Cast("uint8_t") byte arg5);
	public native @Cast("bool") @Name("operator bool") boolean asBoolean();
}

/**
 * \brief The complete address of an ADS device can be stored in this structure.
 */
public static class AmsAddr extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public AmsAddr() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public AmsAddr(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public AmsAddr(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public AmsAddr position(long position) {
        return (AmsAddr)super.position(position);
    }
    @Override public AmsAddr getPointer(long i) {
        return new AmsAddr((Pointer)this).offsetAddress(i);
    }

	/** AMS Net Id */
	public native @ByRef AmsNetId netId(); public native AmsAddr netId(AmsNetId setter);

	/** AMS Port number */
	public native @Cast("uint16_t") short port(); public native AmsAddr port(short setter);
}

/**
 * \brief The structure contains the version number, revision number and build number.
 */
public static class AdsVersion extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public AdsVersion() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public AdsVersion(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public AdsVersion(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public AdsVersion position(long position) {
        return (AdsVersion)super.position(position);
    }
    @Override public AdsVersion getPointer(long i) {
        return new AdsVersion((Pointer)this).offsetAddress(i);
    }

	/** Version number. */
	public native @Cast("uint8_t") byte version(); public native AdsVersion version(byte setter);

	/** Revision number. */
	public native @Cast("uint8_t") byte revision(); public native AdsVersion revision(byte setter);

	/** Build number */
	public native @Cast("uint16_t") short build(); public native AdsVersion build(short setter);
}

/** enum ADSTRANSMODE */
public static final int
	ADSTRANS_NOTRANS = 0,
	ADSTRANS_CLIENTCYCLE = 1,
	ADSTRANS_CLIENTONCHA = 2,
	ADSTRANS_SERVERCYCLE = 3,
	ADSTRANS_SERVERONCHA = 4,
	ADSTRANS_SERVERCYCLE2 = 5,
	ADSTRANS_SERVERONCHA2 = 6,
	ADSTRANS_CLIENT1REQ = 10,
	ADSTRANS_MAXMODES = 11;

/** enum ADSSTATE */
public static final short
	ADSSTATE_INVALID = (short)(0),
	ADSSTATE_IDLE = (short)(1),
	ADSSTATE_RESET = (short)(2),
	ADSSTATE_INIT = (short)(3),
	ADSSTATE_START = (short)(4),
	ADSSTATE_RUN = (short)(5),
	ADSSTATE_STOP = (short)(6),
	ADSSTATE_SAVECFG = (short)(7),
	ADSSTATE_LOADCFG = (short)(8),
	ADSSTATE_POWERFAILURE = (short)(9),
	ADSSTATE_POWERGOOD = (short)(10),
	ADSSTATE_ERROR = (short)(11),
	ADSSTATE_SHUTDOWN = (short)(12),
	ADSSTATE_SUSPEND = (short)(13),
	ADSSTATE_RESUME = (short)(14),
	ADSSTATE_CONFIG = (short)(15),
	ADSSTATE_RECONFIG = (short)(16),
	ADSSTATE_STOPPING = (short)(17),
	ADSSTATE_INCOMPATIBLE = (short)(18),
	ADSSTATE_EXCEPTION = (short)(19),
	ADSSTATE_MAXSTATES = (short)(20);

/**
 * \brief This structure contains all the attributes for the definition of a notification.
 *
 * The ADS DLL is buffered from the real time transmission by a FIFO.
 * TwinCAT first writes every value that is to be transmitted by means
 * of the callback function into the FIFO. If the buffer is full, or if
 * the nMaxDelay time has elapsed, then the callback function is invoked
 * for each entry. The nTransMode parameter affects this process as follows:
 *
 * \par ADSTRANS_SERVERCYCLE
 * The value is written cyclically into the FIFO at intervals of
 * nCycleTime. The smallest possible value for nCycleTime is the cycle
 * time of the ADS server; for the PLC, this is the task cycle time.
 * The cycle time can be handled in 1ms steps. If you enter a cycle time
 * of 0 ms, then the value is written into the FIFO with every task cycle.
 *
 * \par ADSTRANS_SERVERONCHA
 * A value is only written into the FIFO if it has changed. The real-time
 * sampling is executed in the time given in nCycleTime. The cycle time
 * can be handled in 1ms steps. If you enter 0 ms as the cycle time, the
 * variable is written into the FIFO every time it changes.
 *
 * Warning: Too many read operations can load the system so heavily that
 * the user interface becomes much slower.
 *
 * Tip: Set the cycle time to the most appropriate values, and always
 * close connections when they are no longer required.
 */
public static class AdsNotificationAttrib extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public AdsNotificationAttrib() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public AdsNotificationAttrib(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public AdsNotificationAttrib(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public AdsNotificationAttrib position(long position) {
        return (AdsNotificationAttrib)super.position(position);
    }
    @Override public AdsNotificationAttrib getPointer(long i) {
        return new AdsNotificationAttrib((Pointer)this).offsetAddress(i);
    }

	/** Length of the data that is to be passed to the callback function. */
	public native @Cast("uint32_t") int cbLength(); public native AdsNotificationAttrib cbLength(int setter);

	/**
     * ADSTRANS_SERVERCYCLE: The notification's callback function is invoked cyclically.
     * ADSTRANS_SERVERONCHA: The notification's callback function is only invoked when the value changes.
     */
	public native @Cast("uint32_t") int nTransMode(); public native AdsNotificationAttrib nTransMode(int setter);

	/** The notification's callback function is invoked at the latest when this time has elapsed. The unit is 100 ns. */
	public native @Cast("uint32_t") int nMaxDelay(); public native AdsNotificationAttrib nMaxDelay(int setter);
		/** The ADS server checks whether the variable has changed after this time interval. The unit is 100 ns. */
		public native @Cast("uint32_t") int nCycleTime(); public native AdsNotificationAttrib nCycleTime(int setter);
		public native @Cast("uint32_t") int dwChangeFilter(); public native AdsNotificationAttrib dwChangeFilter(int setter);
}

/**
 * \brief This structure is also passed to the callback function.
 */
public static class AdsNotificationHeader extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public AdsNotificationHeader() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public AdsNotificationHeader(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public AdsNotificationHeader(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public AdsNotificationHeader position(long position) {
        return (AdsNotificationHeader)super.position(position);
    }
    @Override public AdsNotificationHeader getPointer(long i) {
        return new AdsNotificationHeader((Pointer)this).offsetAddress(i);
    }

	/** Contains a 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601 (UTC). */
	public native @Cast("uint64_t") long nTimeStamp(); public native AdsNotificationHeader nTimeStamp(long setter);

	/** Handle for the notification. Is specified when the notification is defined. */
	public native @Cast("uint32_t") int hNotification(); public native AdsNotificationHeader hNotification(int setter);

	/** Number of bytes transferred. */
	public native @Cast("uint32_t") int cbSampleSize(); public native AdsNotificationHeader cbSampleSize(int setter);
}

/**
 * \brief Type definition of the callback function required by the AdsSyncAddDeviceNotificationReqEx() function.
 * @param pAddr [in] Structure with NetId and port number of the ADS server.
 * @param pNotification [in] pointer to a AdsNotificationHeader structure
 * @param hUser [in] custom handle pass to AdsSyncAddDeviceNotificationReqEx() during registration
 */
public static class PAdsNotificationFuncEx extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    PAdsNotificationFuncEx(Pointer p) { super(p); }
    protected PAdsNotificationFuncEx() { allocate(); }
    private native void allocate();
    public native void call(
	@Const AmsAddr pAddr, @Const AdsNotificationHeader pNotification,
	@Cast("uint32_t") int hUser);
}

public static native @MemberGetter int ADSSYMBOLFLAG_PERSISTENT();
public static final int ADSSYMBOLFLAG_PERSISTENT = ADSSYMBOLFLAG_PERSISTENT();
public static native @MemberGetter int ADSSYMBOLFLAG_BITVALUE();
public static final int ADSSYMBOLFLAG_BITVALUE = ADSSYMBOLFLAG_BITVALUE();
public static native @MemberGetter int ADSSYMBOLFLAG_REFERENCETO();
public static final int ADSSYMBOLFLAG_REFERENCETO = ADSSYMBOLFLAG_REFERENCETO();
public static native @MemberGetter int ADSSYMBOLFLAG_TYPEGUID();
public static final int ADSSYMBOLFLAG_TYPEGUID = ADSSYMBOLFLAG_TYPEGUID();
public static native @MemberGetter int ADSSYMBOLFLAG_TCCOMIFACEPTR();
public static final int ADSSYMBOLFLAG_TCCOMIFACEPTR = ADSSYMBOLFLAG_TCCOMIFACEPTR();
public static native @MemberGetter int ADSSYMBOLFLAG_READONLY();
public static final int ADSSYMBOLFLAG_READONLY = ADSSYMBOLFLAG_READONLY();
public static native @MemberGetter int ADSSYMBOLFLAG_CONTEXTMASK();
public static final int ADSSYMBOLFLAG_CONTEXTMASK = ADSSYMBOLFLAG_CONTEXTMASK();

/**
 * \brief This structure describes the header of ADS symbol information
 *
 * Calling AdsSyncReadWriteReqEx2 with IndexGroup == ADSIGRP_SYM_INFOBYNAMEEX
 * will return ADS symbol information in the provided readData buffer.
 * The header of that information is structured as AdsSymbolEntry and can
 * be followed by zero terminated strings for "symbol name", "type name"
 * and a "comment"
 */
public static class AdsSymbolEntry extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public AdsSymbolEntry() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public AdsSymbolEntry(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public AdsSymbolEntry(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public AdsSymbolEntry position(long position) {
        return (AdsSymbolEntry)super.position(position);
    }
    @Override public AdsSymbolEntry getPointer(long i) {
        return new AdsSymbolEntry((Pointer)this).offsetAddress(i);
    }

	public native @Cast("uint32_t") int entryLength(); public native AdsSymbolEntry entryLength(int setter); // length of complete symbol entry
	public native @Cast("uint32_t") int iGroup(); public native AdsSymbolEntry iGroup(int setter); // indexGroup of symbol: input, output etc.
	public native @Cast("uint32_t") int iOffs(); public native AdsSymbolEntry iOffs(int setter); // indexOffset of symbol
	public native @Cast("uint32_t") int size(); public native AdsSymbolEntry size(int setter); // size of symbol ( in bytes, 0 = bit )
	public native @Cast("uint32_t") int dataType(); public native AdsSymbolEntry dataType(int setter); // adsDataType of symbol
	public native @Cast("uint32_t") int flags(); public native AdsSymbolEntry flags(int setter); // see ADSSYMBOLFLAG_*
	public native @Cast("uint16_t") short nameLength(); public native AdsSymbolEntry nameLength(short setter); // length of symbol name (null terminating character not counted)
	public native @Cast("uint16_t") short typeLength(); public native AdsSymbolEntry typeLength(short setter); // length of type name (null terminating character not counted)
	public native @Cast("uint16_t") short commentLength(); public native AdsSymbolEntry commentLength(short setter); // length of comment (null terminating character not counted)
}

/**
 * \brief This structure is used to provide ADS symbol information for ADS SUM commands
 */
public static class AdsSymbolInfoByName extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public AdsSymbolInfoByName() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public AdsSymbolInfoByName(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public AdsSymbolInfoByName(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public AdsSymbolInfoByName position(long position) {
        return (AdsSymbolInfoByName)super.position(position);
    }
    @Override public AdsSymbolInfoByName getPointer(long i) {
        return new AdsSymbolInfoByName((Pointer)this).offsetAddress(i);
    }

	public native @Cast("uint32_t") int indexGroup(); public native AdsSymbolInfoByName indexGroup(int setter);
	public native @Cast("uint32_t") int indexOffset(); public native AdsSymbolInfoByName indexOffset(int setter);
	public native @Cast("uint32_t") int cbLength(); public native AdsSymbolInfoByName cbLength(int setter);
}
// #pragma pack(pop)




}
